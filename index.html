<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Galaxy</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: sans-serif; color: white; }
        
        /* Split Screen Layout */
        #container { display: flex; flex-direction: column; height: 100vh; }
        
        /* Galaxy Area */
        #canvas-container { flex: 1; position: relative; background: radial-gradient(circle, #0a0a1a 0%, #000 100%); }
        
        /* Webcam Area */
        #webcam-container { flex: 1; position: relative; background: #111; border-top: 2px solid #333; overflow: hidden; }
        #webcam-video { transform: rotateY(180deg); width: 100%; height: 100%; object-fit: cover; }
        #output-canvas { position: absolute; top: 0; left: 0; transform: rotateY(180deg); width: 100%; height: 100%; object-fit: cover; }

        /* UI Overlay */
        #ui-layer { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; text-shadow: 2px 2px 4px #000; }
        .status-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .data-label { position: absolute; padding: 5px 10px; background: rgba(0,0,0,0.5); border-radius: 4px; pointer-events: none; font-weight: bold; }
    </style>
</head>
<body>

<div id="container">
    <div id="canvas-container">
        <div id="ui-layer">
            <div>Mini Galaxy Interactive</div>
            <div id="fps-counter">Loading Hand Tracking...</div>
        </div>
        <div id="status" class="status-msg">Requesting Camera Access...</div>
    </div>
    <div id="webcam-container">
        <video id="webcam-video" playsinline></video>
        <canvas id="output-canvas"></canvas>
        <div id="chaos-label" class="data-label">Chaos: 0</div>
        <div id="scale-label" class="data-label">Scale: 1</div>
    </div>
</div>

<script>
/** * GALAXY VISUALIZATION (Three.js)
 **/
let scene, camera, renderer, particles, geometry;
const PARTICLE_COUNT = 15000;
let chaosValue = 0;
let scaleValue = 1;

function initGalaxy() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight / 2), 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight / 2);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const initialPositions = new Float32Array(PARTICLE_COUNT * 3);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Spiral galaxy distribution
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 4 + 0.5;
        const spin = radius * 2.5;
        
        const x = Math.cos(angle + spin) * radius;
        const y = (Math.random() - 0.5) * 0.3;
        const z = Math.sin(angle + spin) * radius;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        initialPositions[i * 3] = x;
        initialPositions[i * 3 + 1] = y;
        initialPositions[i * 3 + 2] = z;

        // Space colors (Blue, Purple, White)
        const mixedColor = new THREE.Color();
        const rand = Math.random();
        if (rand > 0.6) mixedColor.setHSL(0.7, 0.8, 0.8); // Purple
        else if (rand > 0.2) mixedColor.setHSL(0.6, 0.9, 0.6); // Blue
        else mixedColor.setHSL(0, 0, 1); // White

        colors[i * 3] = mixedColor.r;
        colors[i * 3 + 1] = mixedColor.g;
        colors[i * 3 + 2] = mixedColor.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.userData.initialPos = initialPositions;

    const material = new THREE.PointsMaterial({
        size: 0.015,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
}

function animateGalaxy() {
    requestAnimationFrame(animateGalaxy);
    
    const pos = geometry.attributes.position.array;
    const initPos = geometry.userData.initialPos;
    const time = Date.now() * 0.001;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // Base Rotation
        const x = initPos[i3];
        const z = initPos[i3 + 2];
        const rotSpeed = (0.5 + (chaosValue * 2)) * 0.01;
        
        // Apply Chaos (Random jitter + convergence)
        const chaosFactor = chaosValue * 2;
        pos[i3] = x * scaleValue + (Math.sin(time + i) * chaosFactor);
        pos[i3 + 1] = initPos[i3+1] + (Math.cos(time + i) * chaosFactor);
        pos[i3 + 2] = z * scaleValue + (Math.sin(time * 0.5 + i) * chaosFactor);

        // High Chaos Collapse Effect
        if (chaosValue > 0.8) {
            pos[i3] *= (1.1 - chaosValue);
            pos[i3+1] *= (1.1 - chaosValue);
            pos[i3+2] *= (1.1 - chaosValue);
        }
    }

    particles.rotation.y += 0.002;
    geometry.attributes.position.needsUpdate = true;
    renderer.render(scene, camera);
}

/** * HAND TRACKING (MediaPipe)
 **/
const videoElement = document.getElementById('webcam-video');
const canvasElement = document.getElementById('output-canvas');
const canvasCtx = canvasElement.getContext('2d');
const chaosLabel = document.getElementById('chaos-label');
const scaleLabel = document.getElementById('scale-label');

function onResults(results) {
    // Resize overlay canvas to match video
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        document.getElementById('status').style.display = 'none';
        
        let indexTips = [];

        results.multiHandLandmarks.forEach((landmarks, index) => {
            // Draw tracking dots
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});

            const indexTip = landmarks[8];
            indexTips.push(indexTip);

            // UI Label Positioning
            const labelX = (1 - indexTip.x) * canvasElement.width;
            const labelY = indexTip.y * canvasElement.height;

            // Gesture logic
            if (results.multiHandedness[index].label === 'Left') {
                // Chaos: Based on distance between Thumb(4) and Pinky(20)
                const thumb = landmarks[4];
                const pinky = landmarks[20];
                const spread = Math.hypot(thumb.x - pinky.x, thumb.y - pinky.y);
                chaosValue = Math.min(Math.max((spread - 0.1) * 3, 0), 1);
                
                chaosLabel.style.left = labelX + 'px';
                chaosLabel.style.top = labelY + 'px';
                chaosLabel.innerText = `Chaos: ${chaosValue.toFixed(2)}`;
            }
        });

        // Scale Logic: Distance between two hands' index fingers
        if (indexTips.length >= 2) {
            const dist = Math.hypot(indexTips[0].x - indexTips[1].x, indexTips[0].y - indexTips[1].y);
            scaleValue = Math.min(Math.max(dist * 3, 0.2), 3);
            
            const midX = (1 - (indexTips[0].x + indexTips[1].x) / 2) * canvasElement.width;
            const midY = ((indexTips[0].y + indexTips[1].y) / 2) * canvasElement.height;
            
            scaleLabel.style.left = midX + 'px';
            scaleLabel.style.top = midY + 'px';
            scaleLabel.innerText = `Scale: ${scaleValue.toFixed(2)}`;
        }
    }
    canvasCtx.restore();
}

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

// Start Application
window.onload = () => {
    initGalaxy();
    animateGalaxy();
    cameraUtils.start().catch(err => {
        document.getElementById('status').innerHTML = "âŒ Camera Error: Please allow camera access and refresh.";
        console.error(err);
    });
};

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / (window.innerHeight / 2);
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight / 2);
});
</script>
</body>
</html>